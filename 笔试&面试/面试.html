<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>面试题</title>
</head>

<body>
    <!-- 08-15 -->
    <!-- <script>
        function getinfo(person, year) {
            person.name = "css"
            year = "1999"
        }
        let per = {
            name: 'test'
        };
        let y = '1998'
        getinfo(per, y)
        console.log(per, y);
        //我猜，css,1998 对象传指针，基本变量赋值传递
    </script> -->
    <!-- 08-14 -->
    <!-- <script>
        function Bar(cb) {
            if (typeof cb !== 'function') {
                return;
            }
            for (var i = 1; i < 4; i++) {
                console.log(cb(i, i - 1)); //输出3次，1，NaN，NaN
                //parseInt(1,0)默认0进制就是parseInt(1),
                //parseInt(2,1)没有1进制，所以返回NaN
                //parseInt(3,2)对于2进制来说，不能有3，所以也是NaN
            }
        }
        //parseInt(s,radix)转换成整数，两个参数分别是，s:值，radix:进制 范围：2-36
        //parseInt(10,2);将2进制的10转换为10进制对应的数是多少，2
        //parseInt(11,16)16进制的11转换成10进制：1*16+1=17
        Bar(parseInt);

        //[1,2,3].map(parseInt);
    </script> -->
    <!-- 08-13 -->
    <!-- <script>
        function foo() {
            this.count++;
        }
        foo.count = 0;
        for (var i = 0; i < 10; i++) {
            if (i % 5) {
                foo()
            }
        }
        console.log(foo.count)
            //0,this的指向问题 因为foo.count=0这句话，是对foo里面定义了一个count变量，然后for循环的foo()是window调用的，也就是全局变量count在++；而不是foo函数里面的count在++；
    </script> -->
    <!-- 08-12 -->
    <!-- 对于getelementbyclassname的这个选择器，是一个动态变化的，你一旦改了其中一个classname，则长度选择到的div长度会发生变化 -->

    <!-- 给定一个数组nums和target，找出和为目标值的两个整数并返回下标 -->
    <!-- 08-11 -->
    <!-- <script>
        function find(nums, target) {
            var cache = [];
            for (var i = 0; i < nums.length; i++) {
                var p1 = nums[i]; //获取值
                var p2 = target - nums[i]; //获取减去p1的值
                var j = cache[p2]; //从缓存中找到我们需要的p2，如果有的话就是之前我们存进去过，直接返回，如果没有的话，我们存进去p1，等待别人需要p1的时候我们再给出来
                //cache的存储方式：数组下标：我们的值，数组内容，nums的值对应的下标
                if (j !== undefined) {
                    return [j, i];
                }
                cache[p1] = i;
            }
            return [];
        }
        console.log(find([5, 11, 23, 14], 28))
    </script> -->


    <!-- 08-07 -->
    <!-- <script>
        function addToList(item, list) {
            return list.push(item)
        }
        var res = addToList('apple', ['banana']);
        console.log(res) //2,,原因如下：因为list.push()的返回值是一个数组的长度
    </script> -->
    <!-- 08-06 -->
    <!-- 行级块元素特点：行级元素有默认的行高（line-height:1-1.2）, 含有默认的垂直方向对齐方式 -->
    <!-- 图片底部1像素空白解决方法： 1、给img添加vertical-align:bottom;(元素的对齐方式) 2、给img父级添加line-height：1ex；表示父元素与子元素一样高；3、给img类型改变成块级元素：display：block；-->
    <!-- 08-04 -->
    <!-- <script>
    // 08-04
    var myObject = {
        foo: 'bar',
        func: function() {
            var self = this;
            console.log(this.foo);
            console.log(self.foo);
            (function() {
                console.log(self.foo)
                console.log(this.foo)
            }());
            (function() {
                console.log(self.foo)
                console.log(this.foo)
            })();
            //上面两种写法没区别
        }
    }
    myObject.func(); //bar bar bar undefined
</script> -->
    <!-- //08 -02
// console.log((function f(n) {
//     return ((n > 1) ? n * f(n - 1) : n)
// })(10)); -->
    <!-- <script>
    //会堆栈溢出
    //改进方法：
    // let res = 1
    // console.log((function f(n) {
    //     if (n > 1) {
    //         (function(n) {
    //             setTimeout(function() {
    //                 res = res + n;
    //                 f(n - 1);
    //             }, 0);
    //         })(n)
    //     }
    //     return n;
    // })(1000000));
    // setTimeout(() => {
    //     console.log(res)
    // }, 10000);

    //10*9*……*1=3,628,800
</script> -->
    <!-- 闭包问题 -->
    <!-- <script>
    // for (var i = 0; i < 10; i++) {
    //     setTimeout(() => {
    //         console.log(i)
    //     }, 0);
    // }
    // //9 9 9 9 9 9 9 9 9 
    // for (var i = 0; i < 10; i++) {
    //     (function(i) {
    //         setTimeout(() => {
    //             console.log(i)
    //         }, 0);
    //     })(i);
    // } //0-9
    // for (let i = 0; i < 10; i++) {
    //     setTimeout(() => {
    //         console.log(i)
    //     }, 0);
    // } //0-9
    // for (var i = 0; i < 10; i++) {
    //     function a(i) {
    //         setTimeout(() => {
    //             console.log(i)
    //         }, 0)
    //     }
    //     a(i)
    // } //0-9
    // for (var i = 0; i < 10; i++) {
    //     new Promise(function(resolve) {
    //         resolve(i)
    //     }).then(i => {
    //         console.log(i)
    //     })
    // } //0-9
</script> -->
    <!--     //07 29
    $(this)和this在jquery中有何不同
    $(this)是一个jquery对象，把this转换成jquery对象，然后可以调用jquery方法。this是操作html对象，返回的是一个html树
-->
    <!-- 07-28 -->
    <!-- css的visibility有个collapse属性在不同的浏览器下以后有什么区别 -->
    <!-- 答：visibility:collapse在table相关的元素（table行，table列 table组）上会隐藏，也会释放空间，与display：none一样; 在其他元素上与display：hidden一样。 -->
    <!-- 在谷歌浏览器用collapse和hidden没有什么区别， 在火狐、opera、ie11里面，则于上面的效果一致-->

    <!-- 07-27 -->

    <!-- 什么是NaN？它的类型是什么，如何可靠的测试一个值是否等于NaN -->

    <!-- 答：NaN属性表示“不是数字”的值，这个特殊值是由于一个造作书是非数字的（例如abc/4）或者是因为操作的结果是非数字而无法执行的 -->

    <!-- 注意：NaN的类型是数字类型: typeof NaN==='number' //true  -->
    <!-- NaN === NaN //false -->

    <!-- 测试数字是否等于NaN的半可靠方法是使用内置函数isNaN() 但是使用isNaN()也不是一个好的解决方案（如isNaN(true)==false） -->
    <!-- 使用value!==值 如果等于NaN，那么只会生成true -->
    <!-- 用Number.isNaN()更好 -->

    <!-- 07-26 -->
    <!-- 函数isOverLap判断两个矩形是否重叠 -->
    <!-- <script>
    function isOverlap(r1, r2) {
        if (((r1.x + r1.width < r2.x) || (r2.x + r2.width < r1.x)) && ((r1.height + r1.y < r2.y) || (r2.y + r2.width < r1.y))) {
            return false;
        }
        return true;
    }
    const rect1 = {
        x: 100,
        y: 100,
        width: 100,
        height: 100
    }
    const rect2 = {
        x: 150,
        y: 150,
        width: 100,
        height: 100
    }
    console.log(isOverlap(rect1, rect2)) //true
</script> -->

    <!-- 07-25 -->
    <!-- <script>
    var d = {};
    ['zbra', 'horse'].forEach(function(k) {
        d[k] = undefined
    })
    console.log(d) //{horse: undefined  zbra: undefined}
</script> -->

    <!-- 07 -24 -->
    <!-- img 标签上的title和alt的属性区别是什么 -->
    <!-- alt当图片不显示时用文字代表。title为该属性提供信息 -->
    <!-- 07-23 -->
    <!-- <script>
    (function() {
        try {
            throw new Error();
        } catch (x) {
            var x = 1,
                y = 2;
            console.log(x);
        }
        console.log(x);
        console.log(y);
    })();
    //1
    //undefined
    //2
    //一开始var变量提升x和y确实都被变量提升了，但还没赋值，
    //catch丢了一个x，这个x是在catch块内部的一个变量，然后再catch{}中，x=1赋值的是catch内部的变量，y因为内部没有y，所以赋值的是全局的变量。
</script> -->

    <!-- 07-22 -->
    <!-- jq  DOM Ready时间如何获取?如何优化 -->
    <!-- 高级浏览器通过DOMContentLoaded事件获取 -->
    <!-- 低版本webkit内核浏览器可以通过轮询document.readyState来实现 -->
    <!-- ie中可以通过settimeout不断调用documentElement的doScroll方法，直到其可以用来实现 -->
    <!-- 优化建议：减少dom接口的复杂度，节点尽可能少，嵌套不要太深，优化关键呈现路径 -->

    <!-- 07-20 -->
    <!-- <script>
    var bar = 1;

    function foo(bar) {
        bar = 2; //函数内部形参bar，被赋值，而不是全局被赋值，全局就是this.bar=2
        alert(bar); //2
    }
    foo(bar)
    alert(bar) //1
</script> -->
    <!-- 07-19 -->
    <!-- <script>
    var a = 0,
        b = 0;

    function A(a) {
        A = function(b) {
            alert(a + b++);
        }
        alert(a++);
    }
    A(1); //1
    A(2); //4
    //一开始A(1)alert（a++）后a变成了2，同时A变量再被变成function（b）
    //A(2)调用的是function(b),即alert(2,b)弹出4，闭包a
</script> -->

    <!-- 07-18 -->
    <!-- 去除字符串当中的字母 “a12f3ba456h345d” -->
    <!-- <script>
    let a = 'a12f3ba456h345d';
    let r = /[a-zA-Z]/g
    console.log(a.replace(r, ""));
</script> -->

    <!-- 07-17 -->
    <!-- 事件的冒泡和捕获：
    事件冒泡：子元素和父元素都绑定了一个事件，然后触发该事件时，子元素先触发，父元素晚触发
    标准解释：当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，直到window。
    取消方法：标准：e.stopPropagation IE:e.cancelBubble=true;
    不会产生冒泡的几种事件：blur，focus（input不存在冒泡机制），load，unload
    事件捕获：就是从dom从顶往底，dom->body->div->……

    事件捕获->处理目标->事件冒泡
 -->
    <!-- <script>
    // 取消绑定的例子
    function stopBubble(e) {
        //如果提供了事件对象，则这是一个非IE浏览器
        if (e && e.stopPropagation)
        //因此它支持W3C的stopPropagation()方法
            e.stopPropagation();
        else
        //否则，我们需要使用IE的方式来取消事件冒泡
            window.event.cancelBubble = true;
    }
    // demo
    var div2 = document.getElementById("div2");
    var div1 = document.getElementById("div1");

    div2.onclick = function(ev) { // 红色面板加事件
        div1.style.display = "block";
        stopBubble(ev); //这样就不会再冒泡给父级了 
    };
    document.onclick = function() {
        div1.style.display = "none";
    }

    function stopBubble(e) {
        //如果提供了事件对象，则这是一个非IE浏览器
        if (e && e.stopPropagation)
        //因此它支持W3C的stopPropagation()方法
            e.stopPropagation();
        else
        //否则，我们需要使用IE的方式来取消事件冒泡
            window.event.cancelBubble = true;
    }
</script> -->

    <!-- 事件委托：利用冒泡的原理，将事件加到父元素或祖先元素上，触发执行效果。
    举个例子：ul里有10个li，每个li click要显示对应的value
    事件委托可以把onclick事件添加到ul上，然后在ul上获取对应的li的value
    demo如下；
    优点：提高js性能，动态添加dom元素不用添加事件
-->
    <!-- <script>
    var ul = document.getElementById('ul')
    ul.onclick = function(ev) {
        console.log(ev.target.value)
    }
</script> -->

    <!-- 07-16 -->
    <!-- <script>
    var num = 10;
    var obj = {
        num: 0,
        inner: {
            num: 6,
            print: function() {
                console.log(this.num);
            }
        }
    }
    num = 88;
    obj.inner.print() //6
    var fn = obj.inner.print;
    fn(); //88
    (obj.inner.print)(); //6
    (obj.inner.print = obj.inner.print)(); //88  变量赋值返回值是一个print函数，所以自执行函数中，是window调用了print
    console.log(obj.inner.print = obj.inner.print)
</script> -->

    <!-- 07-15 -->
    <!-- <script>
    function Point(x, y) {
        this.x = x;
        this.y = y;
        this.moveTo = function(x, y) {
            this.x = x;
            this.y = y;
            console.log(this.x + " " + this.y)
        }
    }
    var p1 = new Point(0, 0);
    var p2 = {
        x: 0,
        y: 0
    };
    p1.moveTo(1, 1) //1 1
    p1.moveTo.apply(p2, [10, 10]); //先把this指向p2，然后p2的x，y=10，答案: 10,10
</script> -->
    <!-- 07-14 -->
    <!-- <script>
    function a(xx) {
        this.x = xx;
        return this;
    }
    var x = a(5); //调用a的是window,然后var已经变量提升，先声明了，所以此时的x是5，返回的是this，指向window。
    var y = a(6); //调用a的是window,然后又给x赋值变成6，所以最终的x是6而y是一个window指针，y.x也就是x=6
    console.log(x.x) //undefined
    console.log(y.x) //6
</script> -->

    <!-- 07-13 -->
    <!-- <script>
    var arr = [1, 2, 3, 4]
    arr.length = 1;
    console.log(arr) //arr:[1]
</script> -->

    <!-- 07-10 -->
    <!-- <script>
    var a = 10;
    var b = 20;

    function swap(a, b) {
        var temp = a;
        a = b;
        b = temp;
    }
    swap(a, b)
    console.log(a + " " + b) //没有变，因为swap中交换的只是a这个指针，还有b这个指针，而不是对应的值。
</script> -->

</body>
<!-- 闭包 -->
<!-- <script>
    var life = 100;
    const gua = 200;

    // const foo = (A, B) => {
    //     for (let key in B) {
    //         console.log(key)
    //         console.log(B[key])
    //         A[key] = B[key]
    //     }
    //     console.log(A)
    //         // console.log(Object.assign(A, B));
    //         // console.log(A.concat(B))
    // }
    // foo({
    //     a: 1,
    //     c: 3,
    //     d: 4
    // }, {
    //     b: 2
    // });
    // // foo([1, 2, 3, 4], [5])
    const foo = (root, tagName) => {
            if (tagName != null) {
                let res = document.getElementsByTagName(tagName);
                console.log(res)
                return res.length;
            } else {
                let res = []
                for (let i of document.body.children) {
                    console.log(i.children)
                    res.push(i.localName)
                }
                return res
            }

        }
        // console.log(foo(document, 'div'));
        // console.log(foo(document));
        // console.log(document.body.childNodes)
        // var lifefunc = function() {
        //     var lifee = 200;

    //     function a() {
    //         return lifee;
    //     }
    // }
    // console.log(lifefunc.a())

    // // //lifefunc是函数的时候
    // function lifefunc() {
    //     var lifee = 200;

    //     function a() {
    //         return lifee;
    //     }
    //     return a();
    // }
    // console.log(lifefunc())
    //     // lifefunc是变量的时候
    // var p = {
    //     life: 200,
    //     a: function() {
    //         return life;
    //     }
    // }
    // console.log(p)

    // // lifefunc是这样子的话
    // var lifefunc = function() {
    //     var lifee = 200;
    //     // var del = function() {
    //     //     lifee--;
    //     // }
    //     return 
    // }
    // console.log(lifefunc())
    // lifefunc.del
    // console.log(lifefunc())

    // 保密的一个形式
    var lifefunc = (function() {
        var lifee = 200;
        return {
            add() {
                lifee++;
                return lifee;
            },
            del() {
                lifee--;
                return lifee;
            },
            get() {
                return lifee;
            }
        }
    })();
    console.log(lifefunc)
    console.log(lifefunc.add())
    console.log(lifefunc.add())
    console.log(lifefunc.add())
    console.log(window)
</script>-->
<!-- 三羊变色问题 -->
<!--  <script>
    function funcolor(arr) {
        arr.sort((a, b) => {
            return b - a
        })
        console.log(arr)
        for (let i = 0; i < arr.length - 1; i++) {
            let temp = [...arr]
            while (temp[i] > 0) {
                if (temp[0] == temp[1] || temp[0] == temp[2] || temp[1] == temp[2]) {
                    console.log(temp)
                    return true;
                }
                temp[i] -= 2;
                if (i == 0) {
                    temp[1]++;
                    temp[2]++;
                } else if (i == 1) {
                    temp[0]++;
                    temp[2]++;
                }
            }
        }
        return false;
    }
    console.log(funcolor([3, 6, 7]))
</script> -->
<!-- 例题 -->
<!-- <script>
    var a = function() {
        this.b = 3;
    }
    var c = new a();
    a.prototype.b = 9;
    var b = 7;
    a();
    console.log(b);
    console.log(c.b);
</script> -->
<!-- vue的双向绑定 -->
<!-- <script>
    var obj = {};
    Object.defineProperty(obj, 'name', {
        writable: "", //是否可以修改
        configurable: "", //是否可以删除
        enumerable: "", //是否可以枚举
        value: "", //值
        get: function() {
            console.log("get方法")
        },
        set: function() {
            console.log("set方法")
        }
    })
    obj.name = 'test';
    var val = obj.name;

    let obj = {
        name: 'test',
        age: 19,
    }
    let handler = {
        get() {
            console.log("get")
            console.log(arguments)
        },
        set() {
            console.log('set')
        }
    }
    let proxy = new Proxy(obj, handler) 
    proxy.name = 'test2'
    proxy.age = 18
</script>-->
<!-- 版本号排序 -->
<!-- <script>
    // 选择排序法
    const chooseSort = arr => {
            for (let i = 0; i < arr.length; i++) {
                let minindex = i;
                for (let j = i + 1; j < arr.length; j++) {
                    if (arr[j] < arr[minindex]) {
                        minindex = j;
                    }
                }
                [arr[i], arr[minindex]] = [arr[minindex], arr[i]]
            }
            return arr;
        }
        //将if里面的内容替换
        //最终代码
    const versionsort = version => {
        const temp = version.map(v => v.split('.'));
        //变成[[1,45,0],[1,5],[1,6],[3,3,3,3,3,3]]
        //接下来是选择排序
        for (let i = 0; i < temp.length; i++) {
            let minindex = i;
            for (let j = i; j < temp.length; j++) {
                for (let k = 0; k < temp[j].length; k++) {
                    const current = +temp[j][k],
                        min = +temp[minindex][k];
                    if (current < min) {
                        minindex = j;
                    }
                    //只要不等,就立刻结束最内层for循环
                    if (current !== min) {
                        break;
                    }
                }
            }
            [temp[i], temp[minindex]] = [temp[minindex], temp[i]];
        }
        return temp.map(v => v.join('.'))
    }
    console.log(versionsort(['1.45.0', '1.5', '6', '3.3.3.3.3.3.3']))

    // 第二种解法sort
    function rule(str1, str2) {
        var arr1 = str1.split('.'), //去除'.'，将剩下的数字转换为数组
            arr2 = str2.split('.'),
            minLen = Math.min(arr1.length, arr2.length), //取出两个数组中的最小程度
            maxLen = Math.max(arr1.length, arr2.length); //最大长度
        //以最短的数组为基础进行遍历
        for (let i = 0; i < minLen; i++) {
            //这里需要转换后才进行比较，否则会出现'10'<'7'的情况
            if (parseInt(arr1[i]) > parseInt(arr2[i])) {
                return 1; //返回一个大于0的数，表示前者的index比后者的index大
            } else if (parseInt(arr1[i]) < parseInt(arr2[i])) {
                return -1; //返回一个小于0的数，表示前者的index比后者的index小
            }
            //因为不只进行一次计较，所以这里不对相等的两个数进行处理，否则有可能第一次比较就返回，不符合要求
            //这个是为了区分'4.8'和'4.8.0'的情况
            //在前面的比较都相同的情况下，则比较长度
            //位数多的index大
            if (i + 1 == minLen) {
                if (arr1.length > arr2.length) {
                    return 1;
                } else {
                    return -1;
                }
            }
        }
    }
    console.log(['1.45.0', '1.5', '6', '3.3.3.3.3.3.3'].sort(rule))
</script> -->

<!-- 闭包 -->
<!-- <script>
    function a() {
        let flag = 2;

        function fa() {
            console.log(flag);
        }
        return fa();
    }
    a();

    function a() {
        if (true) {
            let b = 2;
        }
        console.log(b)
    }
    a();
</script> -->
<!-- 二叉树 -->
<!-- <script>
    // 路径总和返回true||false
    function hasPathSum(root, sum) {
        if (root == null) return false;
        if (root.left == null && root.right == null) {
            return sum = root.val == 0
        }
        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val)
    }
    // 路径总和返回数组列表
    function pathSum(root, sum) {
        let res = [];
        let huisu = function(root, sum, arr) {
            if (root === null) return;
            arr.push(root.val);
            if (root.left === null && root.right === null && root.val === sum) {
                res.push([...arr])
            }
            huisu(root.left, sum - root.val, arr);
            huisu(root.right, sum - root.val, arr);
            // 回溯，要把arrpop
            arr.pop();
        }
        huisu(root, sum, []);
        return res;
    }
</script> -->
<!-- 单链表 -->
<!-- <script>
    function ListNode(val) {
        this.val = val;
        this.next = null;
    }
    let head = new ListNode('0')
        // 尾插
        //head->1->2->3,要插入4的话，是head->1->2->3->4
    let add = function(head) {
            let first = new ListNode('1')
            let temp = head;
            while (temp.next != null) {
                temp = temp.next;
            }
            temp.next = first;
            first.next = null;
        }
        //头插
        //head->1->2->3,插入4,head->4->1->2->3
    let add2 = function(head) {
        let second = new ListNode('2')
        second.next = head.next;
        head.next = second;
    }
</script> -->
<!-- 二叉树一条和为sum的路径 -->
<!-- <script>
    function hasSum(root, sum) {
        //递归
        if (root == null) {
            return false;
        }
        if (root.left == null && root.right == null) {
            return sum - root.val == 0
        }
        return hasSum(root.left, sum - root.val) || hasSum(root.right, sum - root.val)
    }
</script> -->
<!-- 柯里化sum(2)(3)=sum(2,3) -->
<!-- <script>
    // function sum() {
    //     var num = arguments[0];
    //     if (arguments.length === 1) {
    //         return function(sec) {
    //             console.log(sec)
    //             return num + sec;
    //         }
    //     } else {
    //         var num = 0;
    //         for (let i = 0; i < arguments.length; i++) {
    //             num = num + arguments[i];
    //         }
    //         return num;
    //     }
    // }
    // console.log(sum(2, 3));
    // console.log(sum(2)(3));
</script> -->
<!-- <script>
    function sum(...args) {
        if ([...args].length == 1) {
            let sum2 = [...args][0];
            var suum = function(y) {
                sum2 += y;
                return suum;
            }
            suum.valueOf = function() {
                return sum2;
            }
            suum.toString = function() {
                return sum2;
            }
            return suum;
        } else {
            let sum1 = 0;
            for (var i = 0; i < [...args].length; i++) {
                sum1 += [...args][i];
            }
            return sum1
        }
    }
    console.log(sum()); // 0
    console.log(sum(2, 3, 4)); // 9
    console.log(sum(2)(3)(4)) //9
</script> -->
<!-- 判断两个对象是否相同 -->
<!-- <script>
    function isEqual(obj1, obj2) {
        let o1 = obj1 instanceof Object;
        let o2 = obj2 instanceof Object;
        //如果不是对象或数组，直接判断数据是否相等,同样适用于undefined，null
        if (!o1 || !o2) {
            return obj1 === obj2
        }
        //判断对象或者数组的长度，若不同则返回false
        if (Object.keys(obj1).length != Object.keys(obj2).length) {
            return false;
        }
        //判断是否同为对象或者数组，若不同则返回false
        if (Object.prototype.toString.call(obj1) != Object.prototype.toString.call(obj2)) {
            return false;
        }
        //obj1，obj2 可能是对象 或是 数组
        //注意，for循环中只能返回false，则某一项相同返回true，则不进行后面的判断
        //只能return false ，不能  return obj1[key].toString() == obj2[key].toString();
        for (let key in obj1) {
            let typeKey1 = Object.prototype.toString.call(obj1[key]);
            let typeKey2 = Object.prototype.toString.call(obj2[key]);
            //二者类型不同，返回false
            if (typeKey1 != typeKey2) {
                return false;
            }
            //如果是对象，递归二次对比
            if (typeKey1 == '[object Object]') {
                //如果是对象，递归二次对比
                if (!isEqual(obj1[key], obj2[key])) {
                    return false;
                }
            } else if (typeKey1 == '[object Array]') {
                //如果是数组，则转为字符串对比
                if (obj1[key].toString() != obj2[key].toString()) {
                    return false;
                }
            } else if (obj1[key] != obj2[key]) {
                //如果是字符串或者数字，直接对比值
                return false;
            }
        }
        return true;
    }
</script> -->
<!-- repeat -->
<!-- <script>
    function repeat(func, times, wait) {
        return function(str) {
            for (let i = 0; i < times; i++) {
                setTimeout(func(str), wait);
            }
        }
    }
    var repeatfun = repeat(console.log, 4, 3000);
    repeatfun('helloworld')
</script> -->
<!-- resolve -->
<!-- <script>
</script> -->

<!-- 快排 -->
<!-- <script>
    function Insertion(arr) {
        let len = arr.length;
        let preIndex, current;
        for (let i = 1; i < len; i++) {
            preIndex = i - 1;
            current = arr[i];
            while (preIndex >= 0 && current < arr[preIndex]) {
                arr[preIndex + 1] = arr[preIndex]
                preIndex--;
            }
            arr[preIndex + 1] = current;
        }
        return arr;
    }
    var arr = [3, 5, 7, 8, 9, 33, 55, 77, 22, 44, 56]
    console.log(Insertion(arr))
</script> -->
<!-- bind手撕 -->
<!-- <script>
    function newBind(...args) {
        var that = this;
        var _this = arguments[0];
        let arr = [...args];
        arr.splice(0, 1);
        console.log(arr)
        return function() {
            return that.apply(_this, arr);
        }
    }
    console.log(newBind(this, 1, 2, 3, 4))
</script> -->

</html>