## let:
## 不存在变量提升:
## 暂时性死区:
在对应的大括号（块级作用域）内，如果下面有let tmp声明，则前面赋值报错，因为未定义，暂时性的死区。
```js
var tmp = 123;
if (true) {
    tmp = 'abc'; // ReferenceError
    let tmp;
}
```
## 不允许重复声明：
let和var
## 块级作用域：
通常当我们需要定义一个内部的变量，然后使用完之后销毁的，我们一般都会用一个自执行函数去内部定义一个变量，执行完之后变量回收；  

块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。
```js
// IIFE 写法
(function() {
    var tmp = '...';
}());
// 块级作用域写法
{
    let tmp = "...";
}
```
## 块级作用域与函数声明：
函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。  

ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。  

```js
// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
}
```
上面代码的两种函数声明，根据ES5的规定都是非法的。  

但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。  

**ES6 引入了块级作用域，明确允许在块级作用域之中声明函数**  

块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。  

与let不一样的是函数声明语句在块级作用域之内还是会函数声明提升。

---
---


## const: 
## 暂时性死区：
const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。
## 不允许重复声明：
const声明的常量，也与let一样不可重复声明。

##
const一旦声明变量，就必须立即初始化，不能留到以后赋值。 

复合类型的变量，变量名不指向数据，而是指向数据所在的地址。

如果真的想将对象冻结，应该使用Object.freeze方法。
```js
//4、那么我想要一个对象不可以改变怎么设置呢？
// 考虑到，数组其实也是继承于对象，那么，根据下面三个规则
// Object.preventExtendsion(obj) 用来禁止对象可扩展其它属性
// Object.seal(obj)用来禁止对象删除其它属性和扩展其它属性
// Object.freeze(obj)用来冻结对象，就是所有的属性不能够更改和新增
```